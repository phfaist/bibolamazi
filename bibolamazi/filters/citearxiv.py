################################################################################
#                                                                              #
#   This file is part of the Bibolamazi Project.                               #
#   Copyright (C) 2013 by Philippe Faist                                       #
#   philippe.faist@bluewin.ch                                                  #
#                                                                              #
#   Bibolamazi is free software: you can redistribute it and/or modify         #
#   it under the terms of the GNU General Public License as published by       #
#   the Free Software Foundation, either version 3 of the License, or          #
#   (at your option) any later version.                                        #
#                                                                              #
#   Bibolamazi is distributed in the hope that it will be useful,              #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of             #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              #
#   GNU General Public License for more details.                               #
#                                                                              #
#   You should have received a copy of the GNU General Public License          #
#   along with Bibolamazi.  If not, see <http://www.gnu.org/licenses/>.        #
#                                                                              #
################################################################################

# Py2/Py3 support
from __future__ import unicode_literals, print_function
from past.builtins import basestring
from future.utils import python_2_unicode_compatible, iteritems
from builtins import range
from builtins import str as unicodestr
from future.standard_library import install_aliases
install_aliases()


import re
import os
import os.path
import io
from urllib.error import HTTPError
import logging
logger = logging.getLogger(__name__)

from pybtex.database import BibliographyData;
import pybtex.database.input.bibtex as inputbibtex;

from bibolamazi.core.bibfilter import BibFilter, BibFilterError
from bibolamazi.core.bibfilter.argtypes import CommaStrList
from bibolamazi.core.butils import getbool

import arxiv2bib
from .util import arxivutil

from .util import auxfile


HELP_AUTHOR = u"""\
Cite Arxiv IDs filter by Philippe Faist, (C) 2013, GPL 3+ (with code from Nathan Grigg (C) new BSD license)
"""

HELP_DESC = u"""\
Filter that fills BibTeX files with relevant entries to cite with \cite{1211.1037}
"""

HELP_TEXT = u"""
This filter scans a LaTeX document for citations of the form `\cite{arxiv-id}'
(i.e.  `\cite{XXXX.XXXX}', `\cite{XXXX.XXXXX}' or `\cite{quant-ph/XXXXXXX}'),
and adds the corresponding bibtex items in the combined bibtex database with the
arXiv ID as citation key. The bibtex entry is generated by querying the arXiv
API; you of course need internet access for this.

You should provide the base file name of the LaTeX document, e.g. if your
document is named `mydoc.tex', then you should specify the option
`-sJobname=mydoc'. Note that the AUX file (`mydoc.aux') is actually scanned, and
not the LaTeX document itself; this means that you need to run (Pdf)LaTeX
*before* running bibolamazi.

If the `mydoc.aux' file is in a different directory than the bibolamazi file,
you may specify where to look for the aux file with the option
`-sSearchDirs=...'.

If the option `-dJournalRefInNote' is provided, then the journal reference, as
returned by the arXiv query and if existing, is added in the `note={}' field of
the bibtex entry.


Note: this filter uses some 3rd party code (arxiv2bib) by Nathan Grigg,
available at

  https://github.com/nathangrigg/arxiv2bib

and licensed under the new BSD license.

"""



class CiteArxivFilter(BibFilter):

    helpauthor = HELP_AUTHOR
    helpdescription = HELP_DESC
    helptext = HELP_TEXT

    def __init__(self, jobname, search_dirs=[], prefix="", journal_ref_in_note=False):
        """CiteArxivFilter constructor.

        Arguments:
          - jobname: the base name of the latex file. Will search for jobname.aux and look
              for `\citation{..}' commands as they are generated by latex.
          - search_dirs(CommaStrList): the .aux file will be searched for in this list of
              directories; separate directories with commas e.g. 'path/to/dir1,path/to/dir2'
          - journal_ref_in_note(bool): keep the journal reference given by the arXiv in the
              note={} bibtex field. (default: No)
          - prefix: if set, citations should be in the the form `\cite{prefix:id}' (default:
              no prefix)
        """

        BibFilter.__init__(self);

        self.jobname = jobname
        self.search_dirs = CommaStrList(search_dirs)
        self.journal_ref_in_note = getbool(journal_ref_in_note)
        self.prefix = prefix

        if (not self.search_dirs):
            self.search_dirs = ['.', '_cleanlatexfiles'] # also for my cleanlatex utility :)

        logger.debug('citearxiv: jobname=%r' % (jobname,));


    def getRunningMessage(self):
        return u"citearxiv: parsing & fetching relevant arxiv citations ..."

    
    def action(self):
        return BibFilter.BIB_FILTER_BIBOLAMAZIFILE;

    def requested_cache_accessors(self):
        return [
            arxivutil.ArxivFetchedAPIInfoCacheAccessor
            ]

    def filter_bibolamazifile(self, bibolamazifile):

        arxiv_api_accessor = self.cacheAccessor(arxivutil.ArxivFetchedAPIInfoCacheAccessor)

        citearxiv_uselist = []

        #
        # find and analyze jobname.aux. Look for \citation{...}'s and collect them.
        #

        def add_to_cite_list(citekey):
            if self.prefix:
                if not citekey.startswith(self.prefix+":"):
                    return
                citekey = citekey[len(self.prefix)+1:]

            if (not arxiv2bib.NEW_STYLE.match(citekey) and
                not arxiv2bib.OLD_STYLE.match(citekey)):
                # this is not an arxiv citation key
                return

            # citekey is an arxiv ID
            arxivid = citekey;
            if (arxivid not in citearxiv_uselist):
                citearxiv_uselist.append(arxivid)
                
        auxfile.get_all_auxfile_citations(self.jobname, bibolamazifile,
                                          filtername=self.name(),
                                          search_dirs=self.search_dirs,
                                          return_set=False,
                                          callback=add_to_cite_list,
                                          )
        
        #
        # Now, fetch all bib entries that we need.
        #

        # if there are missing ids, fetch them
        if (citearxiv_uselist):
            arxiv_api_accessor.fetchArxivApiInfo(citearxiv_uselist)

        #
        # Now, include all the entries in citearxiv_uselist
        #
        # Variable bibdata is a pybtex.database.BibliographyData object
        #

        thebibdata = bibolamazifile.bibliographyData();


        addprefix = self.prefix+":" if self.prefix else ""

        for arxivid in citearxiv_uselist:
            dat = arxiv_api_accessor.getArxivApiInfo(arxivid)
            if (dat is None):
                errref = arxiv2bib.ReferenceErrorInfo("ArXiv info for `%s' not in cache"%(arxivid),
                                                      arxivid)
                dat = {
                    'reference': errref,
                    'bibtex': errref.bibtex(),
                    }

            # parse bibtex
            parser = inputbibtex.Parser();
            new_bib_data = None;
            with io.StringIO(unicodestr(dat['bibtex'])) as stream:
                new_bib_data = parser.parse_stream(stream);
            
            # and add them to the main list
            if (len(new_bib_data.entries.keys()) != 1):
                logger.warning("Got more than one bibtex entry when retreiving `%s'!" %(arxivid))

            for val in new_bib_data.entries.values():
                if (not self.journal_ref_in_note and 'note' in val.fields):
                    del val.fields['note'];
                thebibdata.add_entry(addprefix+arxivid, val);

        #
        # yay, done!
        #
        
        return


def bibolamazi_filter_class():
    return CiteArxivFilter

